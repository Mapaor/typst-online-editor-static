(globalThis.TURBOPACK||(globalThis.TURBOPACK=[])).push(["object"==typeof document?document.currentScript:void 0,78060,e=>{"use strict";var t=e.i(55319);e.i(80179);class i{mTimes=new Map;mData=new Map;reset(){this.mTimes.clear(),this.mData.clear()}insertFile(e,t,i){this.mTimes.set(e,i),this.mData.set(e,t)}removeFile(e){this.mTimes.delete(e),this.mData.delete(e)}getMTime(e){if(e.startsWith("/@memory/")&&this.mTimes.has(e))return this.mTimes.get(e)}isFile(){return!0}getRealPath(e){return e}readAll(e){if(e.startsWith("/@memory/")&&this.mData.has(e))return this.mData.get(e)}}class s{am;cache=new Map;constructor(e){this.am=e}resolvePath(e){return`https://packages.typst.org/preview/${e.name}-${e.version}.tar.gz`}pullPackageData(e){let t=new XMLHttpRequest;if(t.overrideMimeType("text/plain; charset=x-user-defined"),t.open("GET",this.resolvePath(e),!1),t.send(null),200===t.status&&(t.response instanceof String||"string"==typeof t.response))return Uint8Array.from(t.response,e=>e.charCodeAt(0))}resolve(e,t){if("preview"!==e.namespace)return;let i=this.resolvePath(e);if(this.cache.has(i))return this.cache.get(i)();let s=this.pullPackageData(e);if(!s)return;let a=`/@memory/fetch/packages/${e.namespace}/${e.name}/${e.version}`,r=[];t.untar(s,(e,t,i)=>{r.push([a+"/"+e,t,new Date(i)])});let o=()=>{for(let[e,t,i]of r)this.am.insertFile(e,t,i);return a};return this.cache.set(i,o),o()}}var a=e.i(29554),r=e.i(47167),o=e.i(36518);let n=void 0!==r.default&&null!=r.default.versions&&null!=r.default.versions.node;class l{mainFilePath;cc;fr;ex;constructor(e){this.cc=e?.compiler||l.buildLocalCompiler,this.fr=e?.fontResolver||l.buildLocalFontResolver,this.ex=e?.renderer||l.buildLocalRenderer,this.mainFilePath="/main.typ",this.providers=[]}setCompiler(e){this.cc=e}async getFontResolver(){return"function"==typeof this.fr?this.fr=await this.fr():this.fr}async getCompiler(){return"function"==typeof this.cc?this.cc=await this.cc():this.cc}async getCompilerReset(){let e=await this.getCompiler();return await e.reset(),e}setRenderer(e){this.ex=e}async getRenderer(){return"function"==typeof this.ex?this.ex=await this.ex():this.ex}providers;use(...e){if(!this.providers)throw Error("already prepare uses for instances");this.providers.push(...e)}static preloadFontFromUrl(e){return l.preloadFonts([e])}static preloadFontData(e){return l.preloadFonts([e])}static preloadFonts(e){return{key:"access-model",forRoles:["compiler"],provides:[(0,t.loadFonts)(e)]}}static disableDefaultFontAssets(){return{key:"access-model",forRoles:["compiler"],provides:[(0,t.disableDefaultFontAssets)()]}}static preloadFontAssets(e){return{key:"access-model",forRoles:["compiler"],provides:[(0,t.preloadFontAssets)(e)]}}static withAccessModel(e){return{key:"access-model",forRoles:["compiler"],provides:[(0,t.withAccessModel)(e)]}}static withPackageRegistry(e){return{key:"package-registry",forRoles:["compiler"],provides:[(0,t.withPackageRegistry)(e)]}}static fetchPackageRegistry(e){let a=e||new i;return{key:"package-registry$fetch",forRoles:["compiler"],provides:[...e?[]:[(0,t.withAccessModel)(a)],(0,t.withPackageRegistry)(new s(a))]}}static fetchPackageBy(e,i){return{key:"package-registry$lambda",forRoles:["compiler"],provides:[(0,t.withPackageRegistry)(new class extends s{pullPackageData(e){return i(e,this.resolvePath(e))}}(e))]}}ccOptions;setCompilerInitOptions(e){this.requireIsUninitialized("compiler",this.cc),this.ccOptions=e}exOptions;setRendererInitOptions(e){this.requireIsUninitialized("renderer",this.ex),this.exOptions=e}setMainFilePath(e){this.mainFilePath=e}getMainFilePath(){return this.mainFilePath}removeTmp(e){return e.mainFilePath.startsWith("/tmp/")?this.unmapShadow(e.mainFilePath):Promise.resolve()}async setFonts(e){let t=await this.getFontResolver();for(let i of e)await t.addLazyFont(i,"blob"in i?i.blob:(0,o.loadFontSync)(i),i);let i=await this.getCompiler();await t.build(async e=>i.setFonts(e))}async addSource(e,t){(await this.getCompiler()).addSource(e,t)}async resetShadow(){(await this.getCompiler()).resetShadow()}async mapShadow(e,t){(await this.getCompiler()).mapShadow(e,t)}async unmapShadow(e){(await this.getCompiler()).unmapShadow(e)}async vector(e){let t=await this.getCompileOptions(e);return(await this.getCompilerReset()).compile(t).then(e=>e.result).finally(()=>this.removeTmp(t))}async pdf(e){let t=await this.getCompileOptions(e);return t.format=a.CompileFormatEnum.pdf,(await this.getCompilerReset()).compile(t).then(e=>e.result).finally(()=>this.removeTmp(t))}async svg(e){return this.transientRender(e,(t,i)=>t.renderSvg({...e,renderSession:i}))}async canvas(e,t){return this.transientRender(t,(i,s)=>i.renderToCanvas({container:e,...t,renderSession:s}))}async query(e){let t=await this.getCompileOptions(e);return(await this.getCompilerReset()).query({...e,...t}).finally(()=>this.removeTmp(t))}async getSemanticTokenLegend(){return(await this.getCompilerReset()).getSemanticTokenLegend()}async getSemanticTokens(e){let t=await this.getCompileOptions(e);return(await this.getCompilerReset()).getSemanticTokens({mainFilePath:t.mainFilePath,resultId:e.resultId}).finally(()=>this.removeTmp(t))}async getCompileOptions(e){if(void 0===e)return{mainFilePath:this.mainFilePath,diagnostics:"none"};if("string"==typeof e)throw Error("please specify opts as {mainContent: '...'} or {mainFilePath: '...'}");{if("mainFilePath"in e)return{...e,diagnostics:"none"};let t=`/tmp/${Math.random().toString(36).replace("0.","")}.typ`;return await this.addSource(t,e.mainContent),{mainFilePath:t,inputs:e.inputs,diagnostics:"none"}}}async getVector(e){if(e&&"vectorData"in e)return e.vectorData;let t=await this.getCompileOptions(e);return(await this.getCompiler()).compile(t).then(e=>e.result).finally(()=>this.removeTmp(t))}async transientRender(e,t){let i=await this.getRenderer();if(!i)throw Error("does not provide renderer instance");let s=await this.getVector(e);return await i.runWithSession(async e=>(i.manipulateData({renderSession:e,action:"reset",data:s}),t(i,e)))}prepareUseOnce=void 0;async prepareUse(){return this.prepareUseOnce?this.prepareUseOnce:this.prepareUseOnce=this.doPrepareUse()}async doPrepareUse(){if(!this.providers)return;let e=await Promise.all(this.providers.map(e=>"function"==typeof e?e():e));if(this.providers=[],c==this&&!e.some(e=>e.key.includes("package-registry")||e.key.includes("access-model")))if(n){let e=Function("m","return import(m)");try{let t=new i,{default:s}=await e("sync-request");c.use(l.withAccessModel(t),l.fetchPackageBy(t,(e,t)=>{let i=s("GET",t);if(200===i.statusCode)return i.getBody(void 0)}))}catch(e){}}else c.use(l.fetchPackageRegistry());let t=await Promise.all(this.providers.map(e=>"function"==typeof e?e():e)),s=this.ccOptions||={},a=s.beforeBuild||=[],r=this.exOptions||={},o=r.beforeBuild||=[];for(let i of[...e,...t])i.forRoles.includes("compiler")&&(this.requireIsUninitialized("compiler",this.cc),a.push(...i.provides)),i.forRoles.includes("renderer")&&(this.requireIsUninitialized("renderer",this.ex),o.push(...i.provides));this.providers=void 0}requireIsUninitialized(e,t,i){if(t&&"function"!=typeof t)throw Error(`${e} has been initialized: ${t}`)}static async buildLocalCompiler(){let{createTypstCompiler:t}=await e.A(34362);await this.prepareUse();let i=t();return await i.init(this.ccOptions),i}static async buildLocalFontResolver(){let{createTypstFontBuilder:t}=await e.A(34362);await this.prepareUse();let i=t();return await i.init(this.ccOptions),i}static async buildGlobalCompiler(){let{createGlobalCompiler:t}=await e.A(991),{createTypstCompiler:i}=await e.A(34362);return await this.prepareUse(),t(i,this.ccOptions)}static async buildLocalRenderer(){let{createTypstRenderer:t}=await e.A(30949);await this.prepareUse();let i=t();return await i.init(this.exOptions),i}static async buildGlobalRenderer(){let{createGlobalRenderer:t}=await e.A(39496),{createTypstRenderer:i}=await e.A(30949);return await this.prepareUse(),t(i,this.exOptions)}}let c=new l({compiler:l.buildGlobalCompiler,renderer:l.buildGlobalRenderer}),p=["/fonts/IBMPlexSans-Regular.ttf","/fonts/IBMPlexSans-Bold.ttf","/fonts/NewCMMath-Regular.otf","/fonts/NewCMMath-Book.otf"],h=["/fonts/NotoColorEmoji.ttf"],u=["/fonts/NotoSansCJKsc-Regular.otf","/fonts/NotoSansCJKsc-Bold.otf"],m=self,d=null,f=Promise.resolve(),g=!1,w=!1,y=Date.now(),v=new Set,F=new i,C=new s(F);async function R(){let e=new URL("/wasm/typst_ts_web_compiler_bg.wasm",self.location.origin).href,t=await fetch(e);return await t.arrayBuffer()}function P(e){return e.startsWith("data:")?e:new URL(e,self.location.origin).href}async function b(e){let i=(0,a.createTypstCompiler)(),s=e.map(P);return await i.init({getModule:R,beforeBuild:[(0,t.loadFonts)(s,{assets:["text"]}),(0,t.withAccessModel)(F),(0,t.withPackageRegistry)(C)]}),i}function T(){let e=[...p];return g&&e.push(...h),w&&e.push(...u),e}async function k(){g||(g=!0,console.log("[Typst] Upgrading compiler with emoji fonts..."),d=Promise.resolve(await b(T())),console.log("[Typst] Emoji fonts loaded successfully"))}async function S(){w||(w=!0,console.log("[Typst] Upgrading compiler with CJK fonts..."),d=Promise.resolve(await b(T())),console.log("[Typst] CJK fonts loaded successfully"))}async function O(e,t){console.log("[Typst] Reinitializing compiler with custom fonts:",t);let i=t.map(t=>(function(e,t){let i=t.toLowerCase().split(".").pop(),s="";for(let t=0;t<e.length;t++)s+=String.fromCharCode(e[t]);let a=btoa(s);return`data:${"ttf"===i?"font/ttf":"font/otf"};base64,${a}`})(e[t],t)),s=[...T(),...i];d=Promise.resolve(await b(s)),t.forEach(e=>v.add(e)),console.log("[Typst] Custom fonts loaded successfully")}async function A(e,t,i={}){y=Date.now();let s=Object.keys(i).filter(e=>e.toLowerCase().endsWith(".ttf")||e.toLowerCase().endsWith(".otf")),a=s.some(e=>!v.has(e));a&&await O(i,s);let r=Object.values(e).join("\n");!a&&/[\uD800-\uDFFF]|[\u2600-\u26FF]|[\u2700-\u27BF]/.test(r)&&await k(),!a&&/[\u4E00-\u9FFF\u3400-\u4DBF\uF900-\uFAFF]|[\u3040-\u309F\u30A0-\u30FF]|[\uAC00-\uD7AF]/.test(r)&&await S();let o=await ((d&&Date.now()-y>18e5&&(console.log("[Typst] Resetting compiler after idle timeout"),d=null,g=!1,w=!1,v.clear()),d)?d:(console.log("[Typst] Initializing new compiler instance"),d=b(p)));for(let[t,i]of Object.entries(e)){let e=t.startsWith("/")?t:"/"+t;o.addSource(e,i)}for(let[e,t]of Object.entries(i)){let i=e.startsWith("/")?e:"/"+e;o.mapShadow(i,t)}let n=t.startsWith("/")?t:"/"+t,l=await o.compile({mainFilePath:n,format:1,diagnostics:"unix"}),c=(l.diagnostics??[]).map(String);if(!l.result){let e=c.length>0?c.join("\n"):"Typst compilation failed with no diagnostic information";throw console.error("[Typst] Compilation failed:",e),Error(e)}return c.length>0&&console.warn("[Typst] Compilation warnings:",c.join("\n")),{pdf:l.result,diagnostics:c}}m.onmessage=e=>{let t=e.data;t&&"compile"===t.type&&(f=f.then(async()=>{try{let{pdf:e,diagnostics:i}=await A(t.files,t.mainFile,t.images),s=new Uint8Array(e.length);s.set(e),m.postMessage({type:"compile-result",id:t.id,ok:!0,pdf:s.buffer,diagnostics:i},[s.buffer])}catch(e){m.postMessage({type:"compile-result",id:t.id,ok:!1,error:e instanceof Error?e.message:String(e),diagnostics:[]})}}))},e.s([],78060)}]);